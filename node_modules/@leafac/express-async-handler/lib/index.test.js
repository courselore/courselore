"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const express_1 = __importDefault(require("express"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const _1 = require(".");
globals_1.test("Synchronous", async () => {
    const app = express_1.default();
    app.get("/error/:exampleParameter", (req, res) => {
        // The following are just examples of using the types from the generics.
        if (false) {
            req.params.exampleParameter;
            res.send({ exampleResponseBody: "exampleResponseBody" });
            req.body.exampleRequestBody;
            req.query.exampleRequestQuery;
            res.locals.exampleLocals;
        }
        throw new Error("Error from the app");
    });
    // Adding the generics to ‘app.use<...>()’ doesn’t work. Don’t ask me why; @types/express are weird with error handlers.
    app.use(((err, req, res, next) => {
        // The following are just examples of using the types from the generics.
        if (false) {
            req.params.exampleParameter;
            res.send({ exampleResponseBody: "exampleResponseBody" });
            req.body.exampleRequestBody;
            req.query.exampleRequestQuery;
            res.locals.exampleLocals;
        }
        throw new Error(`Decorated error from an error handler: ${err}`);
    }));
    const server = app.listen();
    const address = server.address();
    if (address === null || typeof address === "string")
        throw new Error("Invalid address");
    const port = address.port;
    await globals_1.expect(await (await node_fetch_1.default(`http://localhost:${port}/error/hi`)).text()).toMatch("Error: Decorated error from an error handler: Error: Error from the app");
    globals_1.expect(server.listening).toBe(true);
    server.close();
});
globals_1.test("Asynchronous", async () => {
    const app = express_1.default();
    // Adding the generics to ‘app.get<...>()’ would also work, but it’s more consistent to add them to ‘asyncHandler<...>()’.
    app.get("/error/:exampleParameter", _1.asyncHandler(async (req, res) => {
        // The following are just examples of using the types from the generics.
        if (false) {
            req.params.exampleParameter;
            res.send({ exampleResponseBody: "exampleResponseBody" });
            req.body.exampleRequestBody;
            req.query.exampleRequestQuery;
            res.locals.exampleLocals;
        }
        await Promise.resolve();
        throw new Error("Error from the app");
    }));
    // Adding the generics to ‘app.get<...>()’ would *not* work. Don’t ask me why; @types/express are weird with error handlers.
    app.use(_1.asyncErrorHandler(async (err, req, res, next) => {
        // The following are just examples of using the types from the generics.
        if (false) {
            req.params.exampleParameter;
            res.send({ exampleResponseBody: "exampleResponseBody" });
            req.body.exampleRequestBody;
            req.query.exampleRequestQuery;
            res.locals.exampleLocals;
        }
        await Promise.resolve();
        throw new Error(`Decorated error from an error handler: ${err}`);
    }));
    const server = app.listen();
    const address = server.address();
    if (address === null || typeof address === "string")
        throw new Error("Invalid address");
    const port = address.port;
    await globals_1.expect(await (await node_fetch_1.default(`http://localhost:${port}/error/hi`)).text()).toMatch("Error: Decorated error from an error handler: Error: Error from the app");
    globals_1.expect(server.listening).toBe(true);
    server.close();
});
//# sourceMappingURL=index.test.js.map